"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const css_1 = require("./css");
const css_numeric_value_1 = require("./css-numeric-value");
class CSSUnitValue extends css_numeric_value_1.CSSNumericValue {
    constructor(value, unit) {
        super();
        this.value = this.resolveValue(value);
        this.unit = css_1.CSS.resolveUnit(unit);
        this.type = this.createType(unit);
    }
    resolveValue(value) {
        if (Number.isNaN(value) || Math.abs(value) === Infinity) {
            console.log('Invalid value', value);
            throw new TypeError(`Failed to set the 'value' property on 'CSSUnitValue': Invalid value ${value}`);
        }
        return Number(value);
    }
    static fromSumValue(sum) {
        let unitMap = sum[0][1];
        if (unitMap.size > 1) {
            throw new TypeError(`Failed to construct CSSUnitValue from sum value ${sum}: Too many entries in unit map`);
        }
        if (!unitMap.size) {
            return new CSSUnitValue(sum[0][1], 'number');
        }
        let unit = Array.from(unitMap.entries())[0];
        if (unit[1] !== 1) {
            throw new TypeError(`Failed to construct CSSUnitValue from sum value ${sum}: Power is not 1`);
        }
        return new CSSUnitValue(sum[0][0], unit[0]);
    }
    toUnit(unit) {
        if (this.unit.name === unit)
            return this;
        if (!css_1.CSS.areCompatible(this.unit.name, unit)) {
            throw new TypeError(`Failed to convert ${this.unit} to ${unit}: Incompatible units`);
        }
        let newUnitData = css_1.CSS.getUnitData(unit);
        return new CSSUnitValue(this.value * this.unit.toCanonical / newUnitData.toCanonical, unit);
    }
    toString() {
        return `${this.value}${this.unit.symbol}`;
    }
}
exports.CSSUnitValue = CSSUnitValue;
//# sourceMappingURL=css-unit-value.js.map