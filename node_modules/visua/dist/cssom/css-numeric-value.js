"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const css_1 = require("./css");
const css_unit_value_1 = require("./css-unit-value");
const css_style_value_1 = require("./css-style-value");
class CSSUnitMap extends Map {
    equals(other) {
        if (this.size !== other.size)
            return false;
        this.forEach((v, k) => {
            if (!other.has(k))
                return false;
            if (other[k] !== this[k])
                return false;
        });
        return true;
    }
}
exports.CSSUnitMap = CSSUnitMap;
class CSSNumericValue extends css_style_value_1.CSSStyleValue {
    constructor() {
        super(...arguments);
        this.type = new Map();
    }
    add(...values) {
        let rectifiedValues = values.map(CSSNumericValue.rectifyNumberishValue);
        if (this instanceof CSSMathSum) {
            this.values.unshift(rectifiedValues);
        }
        else {
            rectifiedValues.unshift(this);
        }
        if (allUnitValues(rectifiedValues)) {
            if (rectifiedValues.every(haveSameUnit)) {
                return new css_unit_value_1.CSSUnitValue(rectifiedValues.map((item) => item.value)
                    .reduce((acc, val) => acc + val), 
                // @ts-ignore
                this.unit.name);
            }
        }
        this.addTypes(rectifiedValues.map(i => i.type));
        return new CSSMathSum(rectifiedValues);
    }
    sub(...values) {
        let rectifiedValues = values.map(CSSNumericValue.rectifyNumberishValue);
        return this.add(...rectifiedValues.map(this.negate));
    }
    mul(...values) {
        let rectifiedValues = values.map(CSSNumericValue.rectifyNumberishValue);
        if (this instanceof CSSMathProduct) {
            this.values.unshift(rectifiedValues);
        }
        else {
            rectifiedValues.unshift(this);
        }
        if (rectifiedValues.every(isUnitValue)) {
            let unitValues = rectifiedValues;
            let numberValues = unitValues.filter(val => val.unit.name === css_1.CSSUnit.number);
            let nonNumberValues = unitValues.filter(val => val.unit.name !== css_1.CSSUnit.number);
            if (numberValues.length === unitValues.length - 1 &&
                nonNumberValues.length === 1) {
                return new css_unit_value_1.CSSUnitValue(unitValues.map(i => i.value)
                    .reduce((acc, val) => acc * val), nonNumberValues[0].unit.name);
            }
        }
        this.multiplyTypes(rectifiedValues.map(i => i.type));
        return new CSSMathProduct(rectifiedValues);
    }
    div(...values) {
        let rectifiedValues = values.map(CSSNumericValue.rectifyNumberishValue);
        return this.mul(...rectifiedValues.map(this.invert));
    }
    min(...values) {
        let rectifiedValues = values.map(CSSNumericValue.rectifyNumberishValue);
        if (this instanceof CSSMathMin) {
            this.values.unshift(rectifiedValues);
        }
        else {
            rectifiedValues.unshift(this);
        }
        if (rectifiedValues.every(isUnitValue)) {
            let unitValues = rectifiedValues;
            if (unitValues.every(haveSameUnit)) {
                return new css_unit_value_1.CSSUnitValue(Math.min(...unitValues.map(item => item.value)), 
                // @ts-ignore
                this.unit.name);
            }
        }
        this.addTypes(rectifiedValues.map(i => i.type));
        return new CSSMathMin(rectifiedValues);
    }
    max(...values) {
        let rectifiedValues = values.map(CSSNumericValue.rectifyNumberishValue);
        if (this instanceof CSSMathMax) {
            this.values.unshift(rectifiedValues);
        }
        else {
            rectifiedValues.unshift(this);
        }
        if (rectifiedValues.every(isUnitValue)) {
            let unitValues = rectifiedValues;
            if (unitValues.every(haveSameUnit)) {
                return new css_unit_value_1.CSSUnitValue(Math.max(...unitValues.map(item => item.value)), 
                // @ts-ignore
                this.unit.name);
            }
        }
        this.addTypes(rectifiedValues.map(i => i.type));
        return new CSSMathMax(rectifiedValues);
    }
    equals(...values) {
        let rectifiedValues = values.map(CSSNumericValue.rectifyNumberishValue);
        return rectifiedValues.every(val => {
            if (val instanceof css_unit_value_1.CSSUnitValue &&
                this instanceof css_unit_value_1.CSSUnitValue) {
                return val.value === this.value &&
                    val.unit.name === this.unit.name;
            }
            if ((val instanceof CSSMathSum &&
                this instanceof CSSMathSum) ||
                (val instanceof CSSMathProduct &&
                    this instanceof CSSMathProduct) ||
                (val instanceof CSSMathMin &&
                    this instanceof CSSMathMin) ||
                (val instanceof CSSMathMax &&
                    this instanceof CSSMathMax)) {
                if (val.values.length !== this.values.length)
                    return false;
                return !this.values.every((v, i) => v !== val.values[i]);
            }
            if ((val instanceof CSSMathNegate &&
                this instanceof CSSMathNegate) ||
                (val instanceof CSSMathInvert &&
                    this instanceof CSSMathInvert)) {
                return val.value === this.value;
            }
            return false;
        });
    }
    to(unit) {
        this.createType(unit);
        let sum = this.createSumValue();
        if (sum.length > 1) {
            throw new TypeError(`Failed to convert ${typeof this} to ${unit}`);
        }
        let item = css_unit_value_1.CSSUnitValue.fromSumValue(sum);
        return item.toUnit(unit);
    }
    solve() {
        try {
            let sum = this.createSumValue();
            if (sum.length > 1) {
                return this;
            }
            return css_unit_value_1.CSSUnitValue.fromSumValue(sum);
        }
        catch (_a) {
            return this;
        }
    }
    static rectifyNumberishValue(num) {
        if (num instanceof CSSNumericValue) {
            return num;
        }
        return new css_unit_value_1.CSSUnitValue(num, css_1.CSSUnit.number);
    }
    typesHaveSameNonZeroValues(t1, t2) {
        return Array.from(t1.entries())
            .filter(([k, v]) => v !== 0)
            .every(([k, v]) => t2.has(k) && t1.get(k) === t2.get(k)) &&
            Array.from(t2.entries())
                .filter(([k, v]) => v !== 0)
                .every(([k, v]) => t1.has(k) && t1.get(k) === t2.get(k));
    }
    joinTypes(t1, t2, fT) {
        t1.forEach((v, k) => {
            if (!fT.has(k)) {
                fT.set(k, v);
            }
        });
        t2.forEach((v, k) => {
            if (!fT.has(k)) {
                fT.set(k, v);
            }
        });
    }
    applyPercentHintToType(type, hint) {
        if (!type.has(hint)) {
            type.set(hint, 0);
        }
        if (type.has(css_1.CSSBaseType.percent)) {
            type.set(hint, type.get(hint) + type.get(css_1.CSSBaseType.percent));
            type.set(css_1.CSSBaseType.percent, 0);
        }
        type.set('percentHint', hint);
    }
    addTypes(types) {
        return types.reduce((type1, type2) => {
            let finalType = new Map();
            if (type1.has('percentHint')) {
                if (type2.has('percentHint')) {
                    this.applyPercentHintToType(type2, type1.get('percentHint'));
                }
                else {
                    if (type1.get('percentHint') !== type2.get('percentHint')) {
                        throw new TypeError('Failed to construct CSSMathSum: Incompatible types');
                    }
                }
            }
            else {
                if (type2.has('percentHint')) {
                    this.applyPercentHintToType(type1, type2.get('percentHint'));
                }
            }
            if (this.typesHaveSameNonZeroValues(type1, type2)) {
                this.joinTypes(type1, type2, finalType);
                this.applyPercentHintToType(finalType, type1.get('percentHint'));
                return finalType;
            }
            if ((type1[css_1.CSSBaseType.percent] != null &&
                type1[css_1.CSSBaseType.percent] !== 0) ||
                (type2[css_1.CSSBaseType.percent] != null &&
                    type2[css_1.CSSBaseType.percent] !== 0)) {
                if (type1.size < 2 && type2.size < 2) {
                    throw new TypeError('Failed to construct CSSMathSum: Incompatible types');
                }
                if (Array.from(type1.entries())
                    .some(([k, v]) => k !== css_1.CSSBaseType.percent && v !== 0) ||
                    Array.from(type1.entries())
                        .some(([k, v]) => k !== css_1.CSSBaseType.percent && v !== 0)) {
                    const origType1 = new Map(type1);
                    const origType2 = new Map(type2);
                    new Map([...type1, ...type2])
                        .forEach((v, k) => {
                        this.applyPercentHintToType(type1, k);
                        this.applyPercentHintToType(type2, k);
                        if (this.typesHaveSameNonZeroValues(type1, type2)) {
                            this.joinTypes(type1, type2, finalType);
                            this.applyPercentHintToType(finalType, k);
                            return finalType;
                        }
                        type1 = origType1;
                        type2 = origType2;
                    });
                }
                throw new TypeError('Failed to construct CSSMathSum: Incompatible types');
            }
        });
    }
    multiplyTypes(types) {
        return types.reduce((type1, type2) => {
            if (type1.has('percentHint')) {
                if (type2.has('percentHint')) {
                    this.applyPercentHintToType(type2, type1.get('percentHint'));
                }
                else {
                    if (type1.get('percentHint') !== type2.get('percentHint')) {
                        throw new TypeError('Failed to construct CSSMathSum: Incompatible types');
                    }
                }
            }
            else {
                if (type2.has('percentHint')) {
                    this.applyPercentHintToType(type1, type2.get('percentHint'));
                }
            }
            let finalType = new Map(type1);
            type2.forEach((v, k) => {
                if (k !== 'percentHint') {
                    if (!finalType.has(k)) {
                        finalType.set(k, finalType.get(k) + v);
                    }
                    else {
                        finalType.set(k, v);
                    }
                }
            });
            this.applyPercentHintToType(finalType, type1.get('percentHint'));
            return finalType;
        });
    }
    negate(value) {
        if (value instanceof css_unit_value_1.CSSUnitValue) {
            return new css_unit_value_1.CSSUnitValue(-value.value, value.unit.name);
        }
        else if (value instanceof CSSMathNegate) {
            return value.value;
        }
        else {
            return new CSSMathNegate(value);
        }
    }
    invert(value) {
        if (value instanceof css_unit_value_1.CSSUnitValue) {
            if (value.unit.name === css_1.CSSUnit.number) {
                if (value.value == 0) {
                    throw new RangeError('Failed to construct CSSMathInvert: Division by zero');
                }
                else {
                    return new css_unit_value_1.CSSUnitValue(1 / value.value, css_1.CSSUnit.number);
                }
            }
        }
        else if (value instanceof CSSMathInvert) {
            return value.value;
        }
        else {
            return new CSSMathInvert(value);
        }
    }
    createType(unit) {
        let result = new Map();
        const unitData = css_1.CSS.getUnitData(unit);
        if (unitData != null) {
            if (unitData.name === css_1.CSSUnit.number)
                return result;
            result.set(unitData.baseType, 1);
            return result;
        }
        throw new TypeError(`Failed to create type: Invalid unit ${unit}`);
    }
    createTypeFromUnitMap(map) {
        let types = [];
        map.forEach((p, u) => {
            let type = this.createType(u);
            type.set(u, p);
            types.push(type);
        });
        return this.multiplyTypes(types);
    }
    createSumValue() {
        if (this instanceof css_unit_value_1.CSSUnitValue) {
            let value = this.value;
            let unit = this.unit;
            if (unit.toCanonical !== 0) {
                value *= unit.toCanonical;
                unit = css_1.CSS.getCanonicalUnit(unit.name);
            }
            if (unit.name === css_1.CSSUnit.number) {
                return [[value, new CSSUnitMap()]];
            }
            let unitMap = new CSSUnitMap();
            unitMap.set(unit.name, 1);
            return [[value, unitMap]];
        }
        if (this instanceof CSSMathSum) {
            let values = [];
            this.values.forEach(i => {
                let value = i.createSumValue();
                value.forEach(v => {
                    let inValue = values.findIndex(val => val[1].equals(v[1]));
                    if (inValue !== -1) {
                        values[inValue][0] += v[0];
                    }
                    else {
                        values.push(v);
                    }
                });
            });
            let types = values.map(v => this.createTypeFromUnitMap(v[1]));
            this.addTypes(types);
            return values;
        }
        if (this instanceof CSSMathNegate) {
            let values = this.value.createSumValue();
            values.forEach(v => v[0] = -v[0]);
            return values;
        }
        if (this instanceof CSSMathProduct) {
            let values = [[1, new CSSUnitMap()]];
            this.values.forEach(v => {
                let newVals = v.createSumValue();
                let temp = [];
                values.forEach(v1 => {
                    newVals.forEach(v2 => {
                        let item = [
                            v1[0] * v2[0],
                            this.multiplyUnitMaps(v1[1], v2[1]),
                        ];
                        temp.push(item);
                    });
                });
                values = temp;
            });
            return values;
        }
        if (this instanceof CSSMathInvert) {
            let sumVal = this.value.createSumValue();
            if (sumVal.length > 1) {
                throw new TypeError('Failed to create sum value from CSSMathInvert');
            }
            sumVal[0][0] = 1 / sumVal[0][0];
            sumVal[0][1].forEach((v, k) => sumVal[0][1][k] = -v);
            return sumVal;
        }
        if (this instanceof CSSMathMin) {
            let args = this.values.map(v => v.createSumValue());
            if (args.some(v => v.length > 1)) {
                throw new TypeError('Failed to create sum value from CSSMathMin');
            }
            if (args.some((v, i, a) => v[0][1].equlas(a[0][0][1]))) {
                throw new TypeError('Failed to create sum value from CSSMathMin');
            }
            return args.reduce((acc, val) => acc[0][0] < val[0][0] ? acc : val);
        }
        if (this instanceof CSSMathMax) {
            let args = this.values.map(v => v.createSumValue());
            if (args.some(v => v.length > 1)) {
                throw new TypeError('Failed to create sum value from CSSMathMin');
            }
            if (args.some((v, i, a) => v[0][1].equlas(a[0][0][1]))) {
                throw new TypeError('Failed to create sum value from CSSMathMin');
            }
            return args.reduce((acc, val) => acc[0][0] < val[0][0] ? acc : val);
        }
    }
    multiplyUnitMaps(u1, u2) {
        let u1NonZero = new CSSUnitMap(), u2NonZero = new CSSUnitMap();
        u1.forEach((v, k) => {
            if (v !== 0)
                u1NonZero.set(k, v);
        });
        u2.forEach((v, k) => {
            if (v !== 0)
                u2NonZero.set(k, v);
        });
        let result = new CSSUnitMap(u1NonZero);
        u2NonZero.forEach((p, u) => {
            if (result.has(u)) {
                result.set(u, result.get(u) + p);
            }
            else {
                result.set(u, p);
            }
        });
        return result;
    }
}
exports.CSSNumericValue = CSSNumericValue;
var CSSMathOperator;
(function (CSSMathOperator) {
    CSSMathOperator[CSSMathOperator["sum"] = 0] = "sum";
    CSSMathOperator[CSSMathOperator["product"] = 1] = "product";
    CSSMathOperator[CSSMathOperator["negate"] = 2] = "negate";
    CSSMathOperator[CSSMathOperator["invert"] = 3] = "invert";
    CSSMathOperator[CSSMathOperator["min"] = 4] = "min";
    CSSMathOperator[CSSMathOperator["max"] = 5] = "max";
})(CSSMathOperator || (CSSMathOperator = {}));
class CSSMathValue extends CSSNumericValue {
}
exports.CSSMathValue = CSSMathValue;
class CSSMathInvert extends CSSMathValue {
    constructor(value) {
        super();
        this.value = value;
    }
}
exports.CSSMathInvert = CSSMathInvert;
class CSSMathMax extends CSSMathValue {
    constructor(...values) {
        super();
        this.values = values;
    }
}
exports.CSSMathMax = CSSMathMax;
class CSSMathMin extends CSSMathValue {
    constructor(...values) {
        super();
        this.values = values;
    }
}
exports.CSSMathMin = CSSMathMin;
class CSSMathNegate extends CSSMathValue {
    constructor(value) {
        super();
        this.value = value;
    }
}
exports.CSSMathNegate = CSSMathNegate;
class CSSMathProduct extends CSSMathValue {
    constructor(values) {
        super();
        this.values = values;
    }
}
exports.CSSMathProduct = CSSMathProduct;
class CSSMathSum extends CSSMathValue {
    constructor(values) {
        super();
        this.values = values;
    }
}
exports.CSSMathSum = CSSMathSum;
const haveSameUnit = (val, i, arr) => val.unit.name === arr[0].unit.name;
const isUnitValue = i => i instanceof css_unit_value_1.CSSUnitValue;
const allUnitValues = (values) => {
    return values.every(isUnitValue);
};
//# sourceMappingURL=css-numeric-value.js.map