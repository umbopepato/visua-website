---
title: Writing plugins
index: 3
---

There are some cases in which community plugins aren't enough for your project or you need a custom set of plugins for
your very specific needs. Writing visua plugins is very easy, just matter of creating a small typescript class.

#### Start from template

The easiest way of getting started writing plugins is by using visua cli to generate an empty plugin.

The `plugin` command starts an interactive shell that will guide you through the creation of you plugin.

Once finished it should have created a folder called `visua-` followed by the slug you have chosen for your plugin with the following structure:

```
visua-plugin-name/
 |-- test/
      |-- identity.css
      |-- index.spec.ts
 |-- .gitignore
 |-- index.ts
 |-- package.json
 |-- tsconfig.json
```

#### Plugin class

A visua plugin in its most basic form is a typescript class extending visua's `Plugin` class.

In `index.ts` you'll find an empty implementation of `Plugin`: 

```typescript
import {StyleMap, Plugin, OptionsMap} from 'visua';

export default class extends Plugin {

    static get options(): OptionsMap {
        return {};
    }

    run(styleMap: StyleMap, options: {[key: string]: any}) {
        
    }

}
```

Your plugin class must be the default export of this module.

**Options**

If your plugin accepts options then you should implement the `options()` getter to return a non empty `OptionsMap`.
`OptionsMap` is an `Object` whose keys are strings corresponding to your options names without the leading "`--`"
and whose values are either type constructors such as `String` or `Boolean` or `ValueInitializer`s: functions that take
the option's textual value and deserialize it.

Consider the following options:

- `--outFile`, a string representing a filesystem path
- `--overwrite`, a boolean flag
- `--tags`, a comma separated list of tags.

The corresponding implementation of `options()` would be the following:

```typescript
static get options(): OptionsMap {
    return {
        outFile: String,
        overwrite: Boolean,
        tags: (value: string) => value.split(','),
    };
}
```

Choosing camel-case option names is preferable so they don't have to be quoted in the object literal.

**Run**

The `run` method is the entry point of your plugin, called by the cli. The arguments are:

- `styleMap`, the map generated by visua from the identity files of the current project,
- `options`, a `string to any` map of the initialized options the user have provided in the cli.

Here you can get all the variables you need from the map using the [StyleMap API](https://visua.io/reference/style-map).

Note that options are not required to the user so in many cases some of them won't be available in the `options` object.
Always check their existence with the `options.hasOwnProperty()` method before trying to access them and try as much as 
you can to provide a fallback value when they're not set.

If you think you really need an option to be set then check its existence in `options` and if it's not there
throw a `PluginError` specifying in the message that the user should set the option:

```typescript
import {StyleMap, Plugin, OptionsMap, PluginError} from 'visua';

export default class extends Plugin {

    static get options(): OptionsMap {
        return {
            mandatoryOption: String,
        };
    }

    run(styleMap: StyleMap, options: {[key: string]: any}) {
        if (!options.hasOwnProperty('mandatoryOption')) {
            throw new PluginError('Please provide `mandatoryOption`!');
        }
        // ...
    }

}
```

#### Testing

The starter template is already set up for testing with `mocha`, `chai` and `ts-node`. In `test/index.spec.ts` you can
find a basic example of how to test your plugin with mock data.

If you plan to publish the plugin take some time to write a good suite test.

#### A complete example

The following is an example taken from `visua-bootstrap`, a super simple plugin that maps your visua variables 
to [bootstrap theme variables](https://getbootstrap.com/docs/4.1/getting-started/theming/#variable-defaults).

#### Bigger plugins

If your plugin is composed of many typescript files the project can become a bit messy. In this cases consider moving
your typescript source files in a `src/` folder and setting `build/` or `dist/` as output folder in `tsconfig.json`.
Don't forget to change your module's `main` in `package.json` from `index.js` to your new entry point.