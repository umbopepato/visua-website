"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const css_style_value_1 = require("./css-style-value");
const css_keyword_value_1 = require("./css-keyword-value");
const css_unit_value_1 = require("./css-unit-value");
const css_1 = require("./css");
const css_position_value_1 = require("./css-position-value");
class CSSGradientStep {
    constructor(color, position) {
        this.color = color;
        this.position = position;
        if (position && position.unit.baseType !== css_1.CSSBaseType.length && position.unit.baseType !== css_1.CSSBaseType.percent) {
            throw new TypeError('Failed to construct CSSGradientStep: Argument position must be of type <length> or <percentage>');
        }
    }
    toString() {
        return `${this.color}${this.position ? ` ${this.position}` : ''}`;
    }
}
exports.CSSGradientStep = CSSGradientStep;
class CSSGradientValue extends css_style_value_1.CSSStyleValue {
}
exports.CSSGradientValue = CSSGradientValue;
class CSSLinearGradient extends CSSGradientValue {
    constructor(steps, direction = new css_unit_value_1.CSSUnitValue(0, css_1.CSSUnit.deg)) {
        super();
        this.steps = steps;
        this.direction = direction;
        if (direction instanceof css_unit_value_1.CSSUnitValue) {
            if (direction.unit.baseType !== css_1.CSSBaseType.angle) {
                throw new TypeError('Failed to construct CSSLinearGradient: Argument direction must be of type <angle>');
            }
        }
        else {
            if (direction.keywords.length < 1 || direction.keywords.length > 2) {
                throw new TypeError('Failed to construct CSSLinearGradient: Direction must be a <side-or-corner>');
            }
            let degs = direction.keywords.map(k => CSSLinearGradient.sidesOrCorners[k.value]);
            if (degs.length === 2) {
                this.direction = degs[0].add(degs[1]).div(2);
            }
            else {
                this.direction = degs[0];
            }
        }
    }
    static get sidesOrCorners() {
        return {
            top: css_1.CSS.deg(0),
            right: css_1.CSS.deg(90),
            bottom: css_1.CSS.deg(180),
            left: css_1.CSS.deg(270),
        };
    }
    toString() {
        return `linear-gradient(${this.direction == null || this.direction === css_1.CSS.deg(0) ? '' : `${this.direction}, `}${this.steps.map(s => s.toString()).join(', ')})`;
    }
}
exports.CSSLinearGradient = CSSLinearGradient;
class CSSRepeatingLinearGradient extends CSSGradientValue {
    constructor(gradient) {
        super();
        this.gradient = gradient;
    }
    ;
}
exports.CSSRepeatingLinearGradient = CSSRepeatingLinearGradient;
class CSSRadialGradient extends CSSGradientValue {
    constructor(steps, dimensions) {
        super();
        this.steps = steps;
        this.position = dimensions.position || new css_position_value_1.CSSPositionValue([new css_keyword_value_1.CSSKeywordValue('center')]);
        this.size = dimensions.size || new css_keyword_value_1.CSSKeywordValue('farthest-corner');
        this.shape = dimensions.shape || (this.size instanceof css_unit_value_1.CSSUnitValue || this.size instanceof css_keyword_value_1.CSSKeywordValue ? new css_keyword_value_1.CSSKeywordValue('circle') : new css_keyword_value_1.CSSKeywordValue('ellipse'));
        if (this.shape.value === 'circle' && Array.isArray(this.size)) {
            console.log(dimensions.shape);
            throw new TypeError('Failed to construct CSSRadialGradient: A circle <shape> only accepts <length> or <identifier> as size');
        }
        if (this.shape.value === 'ellipse' && this.size instanceof css_unit_value_1.CSSUnitValue) {
            throw new TypeError('Failed to construct CSSRadialGradient: An ellipse <shape> only accepts [<length> | <percentage>]{2} or <identifier> as size');
        }
    }
    hasDefaultSize() {
        return this.size instanceof css_keyword_value_1.CSSKeywordValue && this.size.value === 'farthest-corner';
    }
    hasDefaultShape() {
        return this.shape.value === 'circle';
    }
    hasDefaultPosition() {
        return this.position.isCenter;
    }
    toString() {
        let dimensions = [];
        if (!this.hasDefaultSize()) {
            if (this.size instanceof css_unit_value_1.CSSUnitValue || this.size instanceof css_keyword_value_1.CSSKeywordValue)
                dimensions.push(this.size);
            else
                dimensions.push(this.size.map(s => s.toString()).join(' '));
        }
        if (!this.hasDefaultShape())
            dimensions.push(this.shape);
        if (!this.hasDefaultPosition())
            dimensions.push(`at ${this.position}`);
        return `radial-gradient(${dimensions.length > 0 ? `${dimensions.join(' ')}, ` : ''}${this.steps.map(s => s.toString()).join(', ')})`;
    }
}
exports.CSSRadialGradient = CSSRadialGradient;
class CSSRepeatingRadialGradient extends CSSGradientValue {
    constructor(gradient) {
        super();
        this.gradient = gradient;
    }
    ;
}
exports.CSSRepeatingRadialGradient = CSSRepeatingRadialGradient;
//# sourceMappingURL=css-gradient-value.js.map