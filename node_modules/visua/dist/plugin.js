"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A base class to create Visua CLI plugins
 */
class Plugin {
    /**
     * Plugin command line options map
     *
     * If your plugin uses some options you should override this accessor to return a non-empty `OptionsMap`.
     * For example if your plugin accepts two options:
     *
     * - `optOne`, a boolean flag
     * - `optTwo`, a comma-separated list of strings
     *
     * The corresponding implementation of options would be:
     * ```typescript
     * static get options(): OptionsMap {
     *     return {
     *         optOne: Boolean,
     *         optTwo: (value: string) => value.split(','),
     *     };
     * }
     * ```
     */
    static get options() {
        return {};
    }
    ;
}
exports.Plugin = Plugin;
/**
 * An Error class for plugin exceptions
 */
class PluginError extends Error {
    /**
     * Creates a new PluginError
     *
     * @param message The error's message
     */
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.PluginError = PluginError;
/**
 * A utility template literal tag for writing string templates that corrects indentation
 * and removes lines where at least one interpolation expression is `null` or `undefined`.
 *
 * @param strings
 * @param values
 */
function templatel(strings, ...values) {
    const raw = typeof strings === 'string' ? [strings] : strings.raw;
    const lines = [[]];
    let mindent = null;
    let result;
    for (let i = 0; i < raw.length; i++) {
        const chunkLines = raw[i]
            .replace(/\\n[ \t]*!/g, '')
            .replace(/\\`/g, '`')
            .split('\n');
        lines[lines.length - 1].push(chunkLines.shift());
        lines.push(...chunkLines.map(l => [l]));
        if (i < values.length) {
            lines[lines.length - 1].push(values[i]);
        }
    }
    const lineStrings = lines.filter(line => line.every(item => item != null))
        .map(line => line.join(''));
    lineStrings.forEach(line => {
        const m = line.match(/^(\s+)\S+/);
        if (m) {
            let indent = m[1].length;
            if (!mindent) {
                mindent = indent;
            }
            else {
                mindent = Math.min(mindent, indent);
            }
        }
    });
    if (mindent !== null) {
        const m = mindent;
        result = lineStrings.map(l => l[0] === ' ' ? l.slice(m) : l).join('\n');
    }
    else {
        result = lineStrings.join('\n');
    }
    return result.trim()
        .replace(/\\n/g, '\n');
}
exports.templatel = templatel;
/**
 * A utility template literal tag for writing templates that corrects indentation
 * and prevents `null` and `undefined` values from showing.
 *
 * Unlike `templatel` this doesn't remove entire lines that contain null or undefined expressions.
 *
 * @param strings
 * @param values
 */
function template(strings, ...values) {
    const raw = typeof strings === 'string' ? [strings] : strings.raw;
    let result = '';
    for (let i = 0; i < raw.length; i++) {
        result += raw[i]
            .replace(/\\\n[ \t]*/g, '')
            .replace(/\\`/g, '`');
        if (i < values.length && values[i] != null) {
            result += values[i];
        }
    }
    const lines = result.split("\n");
    let mindent = null;
    lines.forEach(l => {
        let m = l.match(/^(\s+)\S+/);
        if (m) {
            let indent = m[1].length;
            if (!mindent) {
                mindent = indent;
            }
            else {
                mindent = Math.min(mindent, indent);
            }
        }
    });
    if (mindent !== null) {
        const m = mindent;
        result = lines.map(l => l[0] === " " ? l.slice(m) : l).join("\n");
    }
    return result
        .trim()
        .replace(/\\n/g, "\n");
}
exports.template = template;
//# sourceMappingURL=plugin.js.map