"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
const css_style_value_1 = require("./css-style-value");
var CSSTimingFunction;
(function (CSSTimingFunction) {
    CSSTimingFunction["ease"] = "ease";
    CSSTimingFunction["easeIn"] = "ease-in";
    CSSTimingFunction["easeOut"] = "ease-out";
    CSSTimingFunction["easeInOut"] = "ease-in-out";
    CSSTimingFunction["linear"] = "linear";
    CSSTimingFunction["stepStart"] = "step-start";
    CSSTimingFunction["stepEnd"] = "step-end";
    CSSTimingFunction["cubicBezier"] = "cubic-bezier";
    CSSTimingFunction["steps"] = "steps";
    CSSTimingFunction["frames"] = "frames";
})(CSSTimingFunction = exports.CSSTimingFunction || (exports.CSSTimingFunction = {}));
var CSSStepPosition;
(function (CSSStepPosition) {
    CSSStepPosition["start"] = "start";
    CSSStepPosition["end"] = "end";
})(CSSStepPosition = exports.CSSStepPosition || (exports.CSSStepPosition = {}));
class CSSTimingFunctionValue extends css_style_value_1.CSSStyleValue {
    constructor(type) {
        super();
        this.type = type;
    }
    is(type) {
        return this.type === type;
    }
    toString() {
        return `${this.type}`;
    }
}
exports.CSSTimingFunctionValue = CSSTimingFunctionValue;
class CSSCubicBezierTimingFunction extends CSSTimingFunctionValue {
    constructor(x1, y1, x2, y2) {
        super(CSSTimingFunction.cubicBezier);
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        if (!util_1.inRange(x1, 0, 1))
            throw new TypeError('Failed to construct CSSCubicBezierFunction: Coordinate x1 is not in [0, 1]');
        if (!util_1.inRange(x2, 0, 1))
            throw new TypeError('Failed to construct CSSCubicBezierFunction: Coordinate x2 is not in [0, 1]');
    }
    toString() {
        return `cubic-bezier(${this.x1}, ${this.y1}, ${this.x2}, ${this.y2})`;
    }
}
exports.CSSCubicBezierTimingFunction = CSSCubicBezierTimingFunction;
class CSSStepsTimingFunction extends CSSTimingFunctionValue {
    constructor(steps, position = CSSStepPosition.end) {
        super(CSSTimingFunction.steps);
        this.steps = steps;
        this.position = position;
        if (!Number.isInteger(steps) || steps <= 0)
            throw new TypeError('Failed to construct CSSStepsTimingFunction: Argument steps must be a positive integer');
    }
    toString() {
        return `steps(${this.steps}${this.position === CSSStepPosition.end ? '' : `, ${this.position}`})`;
    }
}
exports.CSSStepsTimingFunction = CSSStepsTimingFunction;
class CSSFramesTimingFunction extends CSSTimingFunctionValue {
    constructor(frames) {
        super(CSSTimingFunction.frames);
        this.frames = frames;
        if (!Number.isInteger(frames) || frames < 1)
            throw new TypeError('Failed to construct CSSFramesTimingFunction: Argument frames must be an integer grater than 1');
    }
    toString() {
        return `frames(${this.frames})`;
    }
}
exports.CSSFramesTimingFunction = CSSFramesTimingFunction;
//# sourceMappingURL=css-timing-function-value.js.map