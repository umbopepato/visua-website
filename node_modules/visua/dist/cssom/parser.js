"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const css_tree_1 = require("css-tree");
const style_map_1 = require("./style-map");
const css_color_value_1 = require("./css-color-value");
const css_numeric_value_1 = require("./css-numeric-value");
const css_unit_value_1 = require("./css-unit-value");
const css_url_value_1 = require("./css-url-value");
const css_transform_value_1 = require("./css-transform-value");
const dom_matrix_1 = require("./dom-matrix");
const css_translate_1 = require("./css-translate");
const css_1 = require("./css");
const css_scale_1 = require("./css-scale");
const css_rotate_1 = require("./css-rotate");
const css_skew_1 = require("./css-skew");
const css_perspective_1 = require("./css-perspective");
const css_keyword_value_1 = require("./css-keyword-value");
const css_position_value_1 = require("./css-position-value");
const fsPath = require("path");
const util_1 = require("../util");
const css_string_value_1 = require("./css-string-value");
const logger_1 = require("../logger");
const css_timing_function_value_1 = require("./css-timing-function-value");
const css_gradient_value_1 = require("./css-gradient-value");
const css_font_family_value_1 = require("./css-font-family-value");
const css_font_value_1 = require("./css-font-value");
const css_border_value_1 = require("./css-border-value");
const css_box_shadow_value_1 = require("./css-box-shadow-value");
const css_filter_value_1 = require("./css-filter-value");
const fs = require("fs");
const TRANSFORM_FUNCTIONS = [
    'matrix',
    'translate',
    'translateX',
    'translateY',
    'scale',
    'scaleX',
    'scaleY',
    'rotate',
    'skew',
    'skewX',
    'skewY',
    'matrix3d',
    'translate3d',
    'translateZ',
    'scale3d',
    'scaleZ',
    'rotate3d',
    'rotateX',
    'rotateY',
    'rotateZ',
    'perspective',
];
const FILTER_FUNCTIONS = [
    'blur',
    'brightness',
    'contrast',
    'drop-shadow',
    'grayscale',
    'hue-rotate',
    'invert',
    'opacity',
    'sepia',
    'saturate',
];
const POSITION_KEYWORDS = [
    'top',
    'bottom',
    'left',
    'right',
    'center',
];
const TIMING_FUNCTION_KEYWORDS = [
    'ease',
    'ease-in',
    'ease-out',
    'ease-in-out',
    'linear',
    'step-start',
    'step-end',
];
var CssNodeType;
(function (CssNodeType) {
    CssNodeType["AnPlusB"] = "AnPlusB";
    CssNodeType["Atrule"] = "Atrule";
    CssNodeType["AtrulePrelude"] = "AtrulePrelude";
    CssNodeType["AttributeSelector"] = "AttributeSelector";
    CssNodeType["Block"] = "Block";
    CssNodeType["Brackets"] = "Brackets";
    CssNodeType["CDC"] = "CDC";
    CssNodeType["CDO"] = "CDO";
    CssNodeType["ClassSelector"] = "ClassSelector";
    CssNodeType["Combinator"] = "Combinator";
    CssNodeType["Comment"] = "Comment";
    CssNodeType["Declaration"] = "Declaration";
    CssNodeType["DeclarationList"] = "DeclarationList";
    CssNodeType["Dimension"] = "Dimension";
    CssNodeType["Function"] = "Function";
    CssNodeType["HexColor"] = "HexColor";
    CssNodeType["IdSelector"] = "IdSelector";
    CssNodeType["Identifier"] = "Identifier";
    CssNodeType["MediaFeature"] = "MediaFeature";
    CssNodeType["MediaQuery"] = "MediaQuery";
    CssNodeType["MediaQueryList"] = "MediaQueryList";
    CssNodeType["Nth"] = "Nth";
    CssNodeType["Number"] = "Number";
    CssNodeType["Operator"] = "Operator";
    CssNodeType["Parentheses"] = "Parentheses";
    CssNodeType["Percentage"] = "Percentage";
    CssNodeType["PseudoClassSelector"] = "PseudoClassSelector";
    CssNodeType["PseudoElementSelector"] = "PseudoElementSelector";
    CssNodeType["Ratio"] = "Ratio";
    CssNodeType["Raw"] = "Raw";
    CssNodeType["Rule"] = "Rule";
    CssNodeType["Selector"] = "Selector";
    CssNodeType["SelectorList"] = "SelectorList";
    CssNodeType["String"] = "String";
    CssNodeType["StyleSheet"] = "StyleSheet";
    CssNodeType["TypeSelector"] = "TypeSelector";
    CssNodeType["UnicodeRange"] = "UnicodeRange";
    CssNodeType["Url"] = "Url";
    CssNodeType["Value"] = "Value";
    CssNodeType["WhiteSpace"] = "WhiteSpace";
})(CssNodeType = exports.CssNodeType || (exports.CssNodeType = {}));
class ParseError extends Error {
    constructor(message, location) {
        super(`${message}${location ? `\n    at ${location.source}:${location.start.line}:${location.start.column}` : ``}`);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.ParseError = ParseError;
class Parser {
    constructor(entrypoint, strict = false) {
        this.entrypoint = entrypoint;
        this.strict = strict;
        this.styleMap = new style_map_1.StyleMap();
    }
    parse() {
        const entryAst = parseFile(this.entrypoint, this.strict);
        const parsedFiles = [this.entrypoint];
        const resolveImports = (path, ast) => {
            css_tree_1.walk(ast, {
                visit: 'Atrule',
                enter: (node, item, list) => {
                    if (node.name !== 'import') {
                        util_1.warnAt(`Unexpected at-rule of type @${node.name}. Visua currently only supports @import at-rules`, node.loc);
                        return;
                    }
                    if (nodeIs(node.prelude, CssNodeType.AtrulePrelude)) {
                        if (node.prelude == null || node.prelude.children == null || !node.prelude.children.getSize()) {
                            throw new ParseError(`Invalid import`, node.loc);
                        }
                        let urlNode = node.prelude.children.first();
                        let url;
                        if (nodeIs(urlNode, CssNodeType.String)) {
                            url = urlNode.value;
                        }
                        else if (nodeIs(urlNode, CssNodeType.Url)) {
                            url = urlNode.value.value;
                        }
                        if (typeof url !== 'string') {
                            throw new ParseError(`Invalid import`, urlNode.loc);
                        }
                        url = util_1.removeQuotes(url);
                        let importPath = fsPath.resolve(fsPath.normalize(`${fsPath.dirname(path)}/${url}`));
                        if (!parsedFiles.includes(importPath)) {
                            const importAst = parseFile(importPath, this.strict);
                            parsedFiles.push(importPath);
                            const importStyleSheet = resolveImports(importPath, importAst);
                            list.replace(item, importStyleSheet.children);
                        }
                    }
                    else {
                        throw new ParseError(`Invalid import`, node.loc);
                    }
                },
            });
            return ast;
        };
        const ast = resolveImports(this.entrypoint, entryAst);
        this.analyzeAstAndResolveVariables(ast);
        this.processStyleSheet();
        return this.styleMap;
    }
    analyzeAstAndResolveVariables(ast) {
        const variablesMap = this.generateVariablesMap(ast);
        this.validateVariableReferences(variablesMap);
        this.resolveVariables(ast, variablesMap);
    }
    ;
    generateVariablesMap(ast) {
        const variables = {};
        css_tree_1.walk(ast, {
            visit: CssNodeType.Declaration,
            enter: (node) => {
                if (node.property != null && node.property.startsWith('--')) {
                    let value = nodeIs(node.value, CssNodeType.Value) ? node.value.children.first() : node.value.value;
                    if (!value)
                        throw new ParseError(`Variable ${node.property} is empty`);
                    variables[node.property] = {
                        value: value,
                        internalReferences: [],
                    };
                    css_tree_1.walk(node, {
                        visit: CssNodeType.Identifier,
                        enter: (innerNode) => {
                            if (innerNode.name.startsWith('--')) {
                                variables[node.property].internalReferences.push(innerNode.name);
                            }
                        },
                    });
                }
            },
        });
        return variables;
    }
    ;
    validateVariableReferences(variablesMap) {
        for (let variableKey in variablesMap) {
            if (variablesMap[variableKey].internalReferences.includes(variableKey)) {
                throw new ParseError(`Variable ${variableKey} references itself`);
            }
            variablesMap[variableKey].internalReferences.forEach(variable => {
                if (variable in variablesMap && variablesMap[variable].internalReferences.includes(variableKey)) {
                    throw new ParseError(`Circular variable reference involving ${variableKey} and ${variable}`);
                }
            });
        }
    }
    ;
    resolveVariables(ast, variablesMap) {
        css_tree_1.walk(ast, {
            visit: CssNodeType.Function,
            enter: (node, item, list) => {
                if (node.name === 'var') {
                    const variableName = node.children.first().name;
                    const fallbackValueNode = node.children.filter(param => nodeIs(param, CssNodeType.Value)).first();
                    const fallbackValue = fallbackValueNode.children.first();
                    if (variableName in variablesMap) {
                        list.replace(item, list.createItem(variablesMap[variableName].value));
                    }
                    else if (fallbackValue != null) {
                        list.replace(item, list.createItem(fallbackValue));
                    }
                    else {
                        throw new ParseError(`Undefined variable ${variableName}`, node.loc);
                    }
                }
            },
        });
        this.plainAst = css_tree_1.toPlainObject(ast);
    }
    ;
    processStyleSheet() {
        if (!nodeIs(this.plainAst, CssNodeType.StyleSheet)) {
            throw new ParseError('No stylesheet found');
        }
        const node = this.plainAst;
        if (!node.children || !node.children.length) {
            logger_1.logger.warn('Empty stylesheet found');
            return;
        }
        return node.children.map(c => {
            switch (c.type) {
                case CssNodeType.Atrule:
                    this.processAtRule(c);
                    break;
                case CssNodeType.Rule:
                    this.processRule(c);
                    break;
                default:
                    util_1.warnAt(`Unexpected node ${c.type}`, c.loc);
            }
        });
    }
    ;
    processAtRule(node) {
        if (node.name !== 'import') {
            util_1.warnAt(`Unexpected at-rule of type @${node.name}. Visua currently only supports @import at-rules`, node.loc);
        }
    }
    ;
    processRule(node) {
        if (node.prelude == null ||
            node.prelude.type !== CssNodeType.SelectorList ||
            node.prelude.children == null ||
            !node.prelude.children.length) {
            throw new ParseError(`Couldn't recognize main selector structure. See https://visua.io/guide/structuring-identity-files for guidance on structuring your css files.`, node.loc);
        }
        let mainSelector = node.prelude.children[0].children[0];
        if (!nodeIs(mainSelector, CssNodeType.PseudoClassSelector) || mainSelector.name !== 'root') {
            // @ts-ignore
            util_1.warnAt(`Unexpected selector ${mainSelector.name || ''}. Main selector should be :root`, mainSelector.loc);
            return;
        }
        if (node.block == null || node.block.children == null || !node.block.children.length) {
            logger_1.logger.warn(`Empty identity file`);
        }
        node.block.children.forEach(declaration => {
            if (declaration.type !== CssNodeType.Declaration) {
                throw new ParseError(`Unexpected node ${node.type}`, node.loc);
            }
            try {
                let value = this.convertAstValue(declaration.value);
                if (value != null) {
                    this.styleMap.set(util_1.removeLeadingDashes(declaration.property), value);
                }
            }
            catch (e) {
                if (this.strict)
                    throw e;
                else
                    logger_1.logger.warn(e.formattedMessage || e);
            }
        });
    }
    convertAstValue(node) {
        switch (node.type) {
            case CssNodeType.Value:
                return this.convertDeclaration(node);
            case CssNodeType.Dimension:
                return this.convertDimension(node);
            case CssNodeType.String:
                return this.convertString(node);
            case CssNodeType.Number:
                return this.convertNumber(node);
            case CssNodeType.Function:
                return this.convertFunction(node);
            case CssNodeType.Url:
                return this.convertUrl(node);
            case CssNodeType.HexColor:
                return this.convertHex(node);
            case CssNodeType.Parentheses:
                return this.convertCalc(node.children);
            case CssNodeType.Identifier:
                return this.convertIdentifier(node);
            case CssNodeType.Percentage:
                return this.convertPercentage(node);
        }
    }
    convertDeclaration(node) {
        let normalizedChildren = node.children.filter(removeWhiteSpaces());
        if (normalizedChildren.length > 1) {
            if (node.children.some(c => c.type === CssNodeType.Identifier &&
                POSITION_KEYWORDS.includes(c.name)) ||
                node.children.every(c => c.type === CssNodeType.Percentage || c.type === CssNodeType.Dimension)) {
                return this.convertPosition(node);
            }
            if (node.children.some(c => c.type === CssNodeType.Identifier &&
                c.name === 'inset')) {
                return this.convertBoxShadow(node);
            }
        }
        if (TRANSFORM_FUNCTIONS.includes(normalizedChildren[0].name)) {
            return this.convertTransform(node);
        }
        if (FILTER_FUNCTIONS.includes(normalizedChildren[0].name)) {
            return this.convertFilter(node);
        }
        if (normalizedChildren.every(c => c.type === CssNodeType.Identifier)) {
            return new css_keyword_value_1.CSSKeywordsValue(normalizedChildren.map(c => this.convertAstValue(c)));
        }
        if (normalizedChildren.length < 4 && normalizedChildren.some(c => c.type === CssNodeType.Identifier &&
            css_border_value_1.CSSBorderValue.lineStyleKeywords.includes(c.name))) {
            return this.convertBorder(node);
        }
        let lastChild = normalizedChildren[normalizedChildren.length - 1];
        if (lastChild.type === CssNodeType.Identifier && css_font_family_value_1.CSSFontFamilyValue.fallbackFonts.includes(lastChild.name)) {
            if (normalizedChildren.every(c => c.type === CssNodeType.Identifier || c.type === CssNodeType.String)) {
                return this.convertFontFamily(node);
            }
            else {
                return this.convertFont(node);
            }
        }
        if (node.children.length === 1) {
            return this.convertAstValue(node.children[0]);
        }
        if (normalizedChildren.every(c => c.type === CssNodeType.Identifier ||
            c.type === CssNodeType.HexColor || c.type === CssNodeType.Function ||
            c.type === CssNodeType.Dimension || c.type === CssNodeType.Number)) {
            return this.convertBoxShadow(node);
        }
    }
    convertTransform(node) {
        return new css_transform_value_1.CSSTransformValue(node.children.map(this.convertFunction));
    }
    convertPosition(node) {
        return new css_position_value_1.CSSPositionValue(...node.children
            .filter(removeWhiteSpaces())
            .map(c => this.convertAstValue(c)));
    }
    convertDimension(node) {
        return new css_unit_value_1.CSSUnitValue(node.value, node.unit);
    }
    convertNumber(node) {
        return new css_unit_value_1.CSSUnitValue(node.value, css_1.CSSUnit.number);
    }
    convertFunction(node) {
        switch (node.name) {
            case 'calc':
                return this.convertCalc(node.children);
            case 'min':
                return this.convertMin(node);
            case 'max':
                return this.convertMax(node);
            case 'rgba':
            case 'rgb':
                // @ts-ignore
                return new css_color_value_1.CSSRgbaColor(...node.children
                    .filter(keepTypes(CssNodeType.Number))
                    .map(c => Number(c.value)));
            case 'hsla':
            case 'hsl':
                // @ts-ignore
                return new css_color_value_1.CSSHslaColor(...node.children
                    .filter(keepTypes(CssNodeType.Number, CssNodeType.Percentage, CssNodeType.Dimension))
                    .map(c => {
                    switch (c.type) {
                        case CssNodeType.Number:
                            return c.value;
                        case CssNodeType.Dimension:
                            return this.convertDimension(c);
                        case CssNodeType.Percentage:
                            return this.convertPercentage(c);
                    }
                }));
            case 'matrix':
            case 'matrix3d':
                return new dom_matrix_1.DOMMatrix(node.children
                    .filter(keepTypes(CssNodeType.Number))
                    .map(c => c.value));
            case 'translate':
            case 'translate3d':
                // @ts-ignore
                return new css_translate_1.CSSTranslate(...node.children
                    .filter(keepTypes(CssNodeType.Dimension))
                    .map(this.convertAstValue));
            case 'translateX':
                return new css_translate_1.CSSTranslate(this.convertAstValue(node.children[0]), css_1.CSS.px(0));
            case 'translateY':
                return new css_translate_1.CSSTranslate(css_1.CSS.px(0), this.convertAstValue(node.children[0]));
            case 'translateZ':
                return new css_translate_1.CSSTranslate(css_1.CSS.px(0), css_1.CSS.px(0), this.convertAstValue(node.children[0]));
            case 'scale':
            case 'scale3d':
                if (node.children.length < 3) {
                    return new css_scale_1.CSSScale(this.convertAstValue(node.children[0]), css_1.CSS.px(1));
                }
                // @ts-ignore
                return new css_scale_1.CSSScale(...node.children
                    .filter(keepTypes(CssNodeType.Number))
                    .map(this.convertAstValue));
            case 'scaleX':
                return new css_scale_1.CSSScale(this.convertAstValue(node.children[0]), css_1.CSS.px(0));
            case 'scaleY':
                return new css_scale_1.CSSScale(css_1.CSS.px(0), this.convertAstValue(node.children[0]));
            case 'scaleZ':
                return new css_scale_1.CSSScale(css_1.CSS.px(0), css_1.CSS.px(0), this.convertAstValue(node.children[0]));
            case 'rotate':
                return new css_rotate_1.CSSRotate(this.convertAstValue(node.children[0]));
            case 'rotateX':
                return new css_rotate_1.CSSRotate(this.convertAstValue(node.children[0]), 1, 0, 0);
            case 'rotateY':
                return new css_rotate_1.CSSRotate(this.convertAstValue(node.children[0]), 0, 1, 0);
            case 'rotateZ':
                return new css_rotate_1.CSSRotate(this.convertAstValue(node.children[0]), 0, 0, 1);
            case 'rotate3d': { // Needed because of ts issue #12220
                const params = node.children
                    .filter(keepTypes(CssNodeType.Number, CssNodeType.Dimension))
                    .map(this.convertAstValue);
                return new css_rotate_1.CSSRotate(params[3], params[0], params[1], params[2]);
            }
            case 'skew':
                if (node.children.length < 3) {
                    return new css_skew_1.CSSSkew(this.convertAstValue(node.children[0]), css_1.CSS.px(0));
                }
                // @ts-ignore
                return new css_skew_1.CSSSkew(...node.children
                    .filter(keepTypes(CssNodeType.Dimension, CssNodeType.Number))
                    .map(this.convertAstValue));
            case 'skewX':
                return new css_skew_1.CSSSkew(this.convertAstValue(node.children[0]), css_1.CSS.px(0));
            case 'skewY':
                return new css_skew_1.CSSSkew(css_1.CSS.px(0), this.convertAstValue(node.children[0]));
            case 'perspective':
                return new css_perspective_1.CSSPerspective(this.convertAstValue(node.children[0]));
            case 'cubic-bezier':
                // @ts-ignore
                return new css_timing_function_value_1.CSSCubicBezierTimingFunction(...node.children
                    .filter(keepTypes(CssNodeType.Number))
                    .map(c => c.value));
            case 'steps': {
                const params = node.children.filter(keepTypes(CssNodeType.Number, CssNodeType.Identifier));
                params[0] = Number(params[0].value);
                if (params.length === 2)
                    params[1] = params[1].name;
                // @ts-ignore
                return new css_timing_function_value_1.CSSStepsTimingFunction(...params);
            }
            case 'frames':
                return new css_timing_function_value_1.CSSFramesTimingFunction(Number(node.children[0].value));
            case 'linear-gradient':
                return this.convertLinearGradient(node);
            case 'radial-gradient':
                return this.convertRadialGradient(node);
            case 'repeating-linear-gradient':
                return new css_gradient_value_1.CSSRepeatingLinearGradient(this.convertLinearGradient(node));
            case 'repeating-radial-gradient':
                return new css_gradient_value_1.CSSRepeatingRadialGradient(this.convertRadialGradient(node));
            case 'blur':
                return new css_filter_value_1.CSSBlurFilter(this.convertAstValue(node.children[0]));
            case 'brightness':
                return new css_filter_value_1.CSSBrightnessFilter(this.convertAstValue(node.children[0]));
            case 'contrast':
                return new css_filter_value_1.CSSContrastFilter(this.convertAstValue(node.children[0]));
            case 'drop-shadow':
                return new css_filter_value_1.CSSDropShadowFilter(this.convertBoxShadow(node));
            case 'grayscale':
                return new css_filter_value_1.CSSGrayscaleFilter(this.convertAstValue(node.children[0]));
            case 'hue-rotate':
                return new css_filter_value_1.CSSHueRotateFilter(this.convertAstValue(node.children[0]));
            case 'invert':
                return new css_filter_value_1.CSSInvertFilter(this.convertAstValue(node.children[0]));
            case 'opacity':
                return new css_filter_value_1.CSSOpacityFilter(this.convertAstValue(node.children[0]));
            case 'saturate':
                return new css_filter_value_1.CSSSaturateFilter(this.convertAstValue(node.children[0]));
            case 'sepia':
                return new css_filter_value_1.CSSSepiaFilter(this.convertAstValue(node.children[0]));
        }
    }
    convertUrl(node) {
        return new css_url_value_1.CSSUrlValue(node.value.value);
    }
    convertHex(node) {
        return css_color_value_1.CSSHexColor.fromString(node.value);
    }
    convertPercentage(node) {
        return new css_unit_value_1.CSSUnitValue(node.value, 'percent');
    }
    convertCalc(components) {
        const children = components.filter(removeWhiteSpaces());
        if (children.length < 3)
            throw new ParseError(`Failed to convert ${components} to CSSMathValue: Too few arguments`, components[0].loc);
        let top = children.length - 2;
        for (let i = top; i > 0; i -= 2) {
            if (children[i].value === '+' || children[i].value === '-') {
                top = i;
                break;
            }
        }
        return this.convertCalcBinaryExpression(children.slice(0, top), children[top].value, children.slice(top + 1));
    }
    convertCalcBinaryExpression(left, operator, right) {
        let mathValue;
        let leftValue = left.length === 1 ? this.convertAstValue(left[0]) : this.convertCalc(left);
        let rightValue = right.length === 1 ? this.convertAstValue(right[0]) : this.convertCalc(right);
        if (operator === '-')
            rightValue = new css_numeric_value_1.CSSMathNegate(rightValue);
        if (operator === '/')
            rightValue = new css_numeric_value_1.CSSMathInvert(rightValue);
        switch (operator) {
            case '+':
            case '-':
                mathValue = new css_numeric_value_1.CSSMathSum([leftValue, rightValue]);
                break;
            case '*':
            case '/':
                mathValue = new css_numeric_value_1.CSSMathProduct([leftValue, rightValue]);
                break;
        }
        return mathValue.solve();
    }
    convertMin(node) {
        return new css_numeric_value_1.CSSMathMin(...node.children.filter(removeWhiteSpaces())
            .map(this.convertAstValue));
    }
    convertMax(node) {
        return new css_numeric_value_1.CSSMathMax(...node.children.filter(removeWhiteSpaces())
            .map(this.convertAstValue));
    }
    convertIdentifier(node) {
        if (node.name === 'transparent') {
            return new css_color_value_1.CSSRgbaColor(0, 0, 0, 0);
        }
        if (TIMING_FUNCTION_KEYWORDS.includes(node.name)) {
            return new css_timing_function_value_1.CSSTimingFunctionValue(node.name);
        }
        if (css_color_value_1.CSSColorValue.x11ColorsMap.hasOwnProperty(node.name)) {
            return css_color_value_1.CSSHexColor.fromString(css_color_value_1.CSSColorValue.x11ColorsMap[node.name]);
        }
        if (css_font_value_1.CSSSystemFontValue.systemFonts.includes(node.name)) {
            return new css_font_value_1.CSSSystemFontValue(node.name);
        }
        return new css_keyword_value_1.CSSKeywordValue(node.name);
    }
    convertString(node) {
        return new css_string_value_1.CSSStringValue(node.value);
    }
    convertLinearGradient(node) {
        let groups = split(node.children.filter(removeWhiteSpaces()), CssNodeType.Operator);
        let direction;
        let steps = [];
        for (let i = 0; i < groups.length; i++) {
            let group = groups[i];
            if (group.length > 0) {
                if (i == 0 && group[0].type !== CssNodeType.Function && group[0].type !== CssNodeType.HexColor) {
                    if (group[0].type === CssNodeType.Dimension) {
                        direction = this.convertAstValue(group[0]);
                    }
                    else if (group[0].name === 'to') {
                        if (group.length > 1 && group[1].type === CssNodeType.Identifier) {
                            direction = new css_keyword_value_1.CSSKeywordsValue([this.convertAstValue(group[1])]);
                            if (group.length > 2 && group[2].type === CssNodeType.Identifier) {
                                direction.keywords.push(this.convertAstValue(group[2]));
                                if (group.length > 3 && group[3].type === CssNodeType.Identifier) {
                                    direction.keywords.push(this.convertAstValue(group[3]));
                                }
                            }
                        }
                    }
                }
                else {
                    if (group.length === 1) {
                        steps.push(new css_gradient_value_1.CSSGradientStep(this.convertAstValue(group[0])));
                    }
                    else {
                        steps.push(new css_gradient_value_1.CSSGradientStep(this.convertAstValue(group[0]), this.convertAstValue(group[1])));
                    }
                }
            }
        }
        return new css_gradient_value_1.CSSLinearGradient(steps, direction);
    }
    convertRadialGradient(node) {
        let groups = split(node.children.filter(removeWhiteSpaces()), CssNodeType.Operator);
        let steps = [];
        let size;
        let position;
        let shape;
        for (let i = 0; i < groups.length; i++) {
            let group = groups[i];
            if (group.length > 0) {
                if (i == 0 && group[0].type !== CssNodeType.Function && group[0].type !== CssNodeType.HexColor) {
                    let subGroups = splitf(group, n => n.type === CssNodeType.Identifier && n.name === 'at');
                    for (let j = 0; j < subGroups[0].length; j++) {
                        let dimenNode = subGroups[0][j];
                        if (dimenNode.type === CssNodeType.Identifier && dimenNode.name === 'circle' || dimenNode.name === 'ellipse') {
                            shape = new css_keyword_value_1.CSSKeywordValue(dimenNode.name);
                        }
                        else {
                            if (dimenNode.type === CssNodeType.Dimension || dimenNode.type === CssNodeType.Percentage) {
                                if (size instanceof css_unit_value_1.CSSUnitValue) {
                                    size = [size, this.convertAstValue(dimenNode)];
                                }
                                else {
                                    size = this.convertAstValue(dimenNode);
                                }
                            }
                            else {
                                size = new css_keyword_value_1.CSSKeywordValue(dimenNode.name);
                            }
                        }
                    }
                    position = new css_position_value_1.CSSPositionValue(...subGroups[1].map(c => this.convertAstValue(c)));
                }
                else {
                    if (group.length === 1) {
                        steps.push(new css_gradient_value_1.CSSGradientStep(this.convertAstValue(group[0])));
                    }
                    else {
                        steps.push(new css_gradient_value_1.CSSGradientStep(this.convertAstValue(group[0]), this.convertAstValue(group[1])));
                    }
                }
            }
        }
        return new css_gradient_value_1.CSSRadialGradient(steps, {
            size: size,
            position: position,
            shape: shape,
        });
    }
    convertFontFamily(node) {
        return new css_font_family_value_1.CSSFontFamilyValue(node.children
            .filter(keepTypes(CssNodeType.Identifier, CssNodeType.String))
            .map(c => this.convertAstValue(c)));
    }
    convertFont(node) {
        let i = 0, beforeFamily = true;
        let children = node.children.filter(removeWhiteSpaces());
        let components = { family: null };
        while (beforeFamily && i < children.length) {
            let child = children[i];
            switch (child.type) {
                case CssNodeType.Identifier:
                    if (css_font_value_1.CSSFontValue.styleKeywords.includes(child.name)) {
                        components.style = this.convertAstValue(child);
                    }
                    else if (child.name === 'oblique') {
                        let nextChild = children[i + 1];
                        if (nextChild != null && nextChild.type === CssNodeType.Dimension) {
                            components.style = this.convertAstValue(nextChild);
                            i++; // Skip next child
                        }
                        else {
                            components.style = css_1.CSS.deg(14);
                        }
                    }
                    else if (css_font_value_1.CSSFontValue.variantKeywords.includes(child.name)) {
                        components.variant = this.convertAstValue(child);
                    }
                    else if (css_font_value_1.CSSFontValue.weightKeywords.includes(child.name)) {
                        components.weight = this.convertAstValue(child);
                    }
                    else if (css_font_value_1.CSSFontValue.stretchKeywords.includes(child.name)) {
                        components.stretch = this.convertAstValue(child);
                    }
                    break;
                case CssNodeType.Number:
                    if (child.value.length === 3) {
                        components.weight = this.convertAstValue(child);
                    }
                    break;
                case CssNodeType.Operator:
                    if (child.value === '/') {
                        let nextChild = children[i + 1];
                        if (nextChild != null) {
                            components.lineHeight = this.convertAstValue(nextChild);
                            beforeFamily = false;
                        }
                    }
                    break;
                case CssNodeType.Dimension:
                case CssNodeType.Percentage:
                    components.size = this.convertAstValue(child);
                    if (!children.some(c => c.type === CssNodeType.Operator && c.value === '/')) {
                        beforeFamily = false;
                    }
                    break;
            }
            i++;
        }
        components.family = this.convertFontFamily({ children: children.slice(i) });
        return new css_font_value_1.CSSFontValue(components);
    }
    convertBorder(node) {
        let components = { lineStyle: null, color: null };
        let children = node.children.filter(keepTypes(CssNodeType.Identifier, CssNodeType.Number, CssNodeType.Function, CssNodeType.Dimension, CssNodeType.HexColor));
        for (let child of children) {
            if (child.type === CssNodeType.Identifier) {
                if (css_border_value_1.CSSBorderValue.lineStyleKeywords.includes(child.name)) {
                    components.lineStyle = this.convertAstValue(child);
                }
                else if (css_border_value_1.CSSBorderValue.lineWidthKeywords.includes(child.name)) {
                    components.lineWidth = this.convertAstValue(child);
                }
            }
            let value = this.convertAstValue(child);
            if (value instanceof css_color_value_1.CSSColorValue) {
                components.color = value;
            }
            else if (value instanceof css_unit_value_1.CSSUnitValue) {
                components.lineWidth = value;
            }
        }
        return new css_border_value_1.CSSBorderValue(components);
    }
    convertBoxShadow(node) {
        // TODO handle 3 children inset shadow conflicting with border
        let children = node.children.filter(keepTypes(CssNodeType.Number, CssNodeType.Dimension, CssNodeType.Function, CssNodeType.HexColor, CssNodeType.Identifier, CssNodeType.Operator));
        let shadows = splitf(children, c => c.type === CssNodeType.Operator && c.value === '/');
        let layers = [];
        shadows.forEach(s => {
            let components = { color: null };
            s.forEach(c => {
                let value = this.convertAstValue(c);
                if (value instanceof css_keyword_value_1.CSSKeywordValue && value.value === 'inset') {
                    components.inset = true;
                }
                else if (value instanceof css_unit_value_1.CSSUnitValue) {
                    if (components.offsetX == null) {
                        components.offsetX = value;
                    }
                    else if (components.offsetY == null) {
                        components.offsetY = value;
                    }
                    else if (components.blurRadius == null) {
                        components.blurRadius = value;
                    }
                    else if (components.spreadDistance == null) {
                        components.spreadDistance = value;
                    }
                }
                else if (value instanceof css_color_value_1.CSSColorValue) {
                    components.color = value;
                }
            });
            layers.push(new css_box_shadow_value_1.CSSShadow(components));
        });
        return new css_box_shadow_value_1.CSSBoxShadowValue(layers);
    }
    convertFilter(node) {
        let children = node.children.filter(keepTypes(CssNodeType.Function));
        return new css_filter_value_1.CSSFilterValue(children.map(c => this.convertFunction(c)));
    }
}
exports.Parser = Parser;
const parseFile = (path, strict = false) => {
    let fileContent;
    try {
        fileContent = fs.readFileSync(path, { encoding: 'UTF-8' });
    }
    catch (e) {
        throw new TypeError(`Failed to load identity file ${path}`);
    }
    return css_tree_1.parse(fileContent, {
        parseCustomProperty: true,
        onParseError: (error) => {
            if (strict) {
                throw error;
            }
            else {
                logger_1.logger.warn(error);
            }
        },
        positions: true,
        filename: path,
    });
};
const nodeIs = (node, type) => {
    return node.type === type;
};
const removeWhiteSpaces = () => {
    return node => {
        return node.type !== CssNodeType.WhiteSpace;
    };
};
const keepTypes = (...types) => {
    return node => {
        return types.some(t => node.type === t);
    };
};
const split = (nodes, splitter) => {
    let result = [[]];
    nodes.forEach(n => {
        if (n.type === splitter) {
            result.push([]);
        }
        else {
            result[result.length - 1].push(n);
        }
    });
    return result;
};
const splitf = (nodes, splitter) => {
    let result = [[]];
    nodes.forEach(n => {
        if (splitter(n)) {
            result.push([]);
        }
        else {
            result[result.length - 1].push(n);
        }
    });
    return result;
};
//# sourceMappingURL=parser.js.map